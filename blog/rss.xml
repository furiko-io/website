<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Furiko Blog</title>
        <link>https://furiko.io/blog</link>
        <description>Furiko Blog</description>
        <lastBuildDate>Wed, 15 Jun 2022 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <item>
            <title><![CDATA[Introducing Furiko, an open-source, Kubernetes-native job platform]]></title>
            <link>https://furiko.io/blog/introducing-furiko</link>
            <guid>introducing-furiko</guid>
            <pubDate>Wed, 15 Jun 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[We're proud to officially introduce the Furiko project - an open-source, Kubernetes-native platform for scheduling, executing and managing ad-hoc and cron jobs. Furiko is able to schedule jobs to be run on a periodic or once-off basis, supports a wide variety of use cases, and is able to scale to millions of executions per day.]]></description>
            <content:encoded><![CDATA[<p>We're proud to officially introduce the Furiko project - an open-source, Kubernetes-native platform for scheduling, executing and managing ad-hoc and cron jobs. Furiko is able to schedule jobs to be run on a periodic or once-off basis, supports a wide variety of use cases, and is able to scale to millions of executions per day.</p><div class="text--center"><img style="background:white;width:500px;padding:50px 100px" src="/assets/images/color_horizontal-96fb6c6b17735c4e0bfa161dc86123a4.png"><p class="caption_y_hk">The word "furiko" (ÊåØ„ÇäÂ≠ê) means "pendulum" in Japanese. <br> Logo designed by Duan Weiwei, distributed under CC-BY 4.0.</p></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="building-furiko-internally">Building Furiko internally<a class="hash-link" href="#building-furiko-internally" title="Direct link to heading">‚Äã</a></h2><p>To provide a bit of background, Furiko was initially developed in 2020 as an internal platform in Shopee. Our goal was to develop the next generation of a Kubernetes-based job platform for our internal users, known internally as <em>Runonce</em>.</p><p>At the time, we were still extensively using <a href="https://www.rundeck.com" target="_blank" rel="noopener noreferrer">Rundeck</a> (now known as <a href="https://www.rundeck.com/open-source" target="_blank" rel="noopener noreferrer">PagerDuty Process Automation</a>) as our main platform to schedule, execute and manage jobs across the company.</p><div class="text--center"><img src="/assets/images/rundeck-execution-c42a9194745675f44aec41807ce12e33.png"><p class="caption_y_hk">Example job execution in Rundeck.<!-- --> <a href="https://docs.rundeck.com/docs/manual/04-jobs.html#following-running-jobs" target="_blank" rel="noopener noreferrer">Image source</a></p></div><p>We were constantly tuning system and JVM parameters, but eventually found ourselves hitting a ceiling with regards to usability, reliability and performance. At one point, our Rundeck instance crashed every other week from running out of memory. This severely affected our users' trust in the platform when their jobs did not run, or when they were stuck indefinitely in an <em>Incomplete</em> state. üò≠</p><p>We sought to provide the same concepts and similar feature set that our users enjoyed while using Rundeck, but develop it as a Kubernetes-native platform so that we could thoroughly reap the benefits of a controller-based model to significantly improve the reliability and performance of the platform.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="why-not-just-use-jobcronjob">Why not just use Job/CronJob?<a class="hash-link" href="#why-not-just-use-jobcronjob" title="Direct link to heading">‚Äã</a></h2><p>The biggest question is probably why we decided to rewrite the Job/CronJob controllers in Kubernetes in the first place. For the most part, they could fulfil our requirements, but our initial evaluation found several issues:</p><ol><li>We needed to support timezones in the CronJob (only recently introduced in v1.24).</li><li>We wanted to support custom cron syntaxes, such as the <code>H</code> format <a href="https://www.jenkins.io/doc/book/pipeline/syntax/#cron-syntax" target="_blank" rel="noopener noreferrer">found in Jenkins</a>. This would greatly help to load balance a large number of CronJobs in a single cluster.</li><li>We wanted to automatically kill the Job if it remains pending for too long, in case the node has issues starting the container, causing the CronJob to get stuck until it is manually resolved.</li><li>We needed to automatically force delete Pods if the node is down and the controller is unable to kill the Job, which may also cause the CronJob to get stuck until the node is recovered.</li><li>We need to ensure that if the CronJob has currently running Jobs, it should not allow a new ad-hoc Job to be run.</li><li>We cannot guarantee that workloads will not be executed more than once, such as from deleting the Pod or being evicted by <code>kube-controller-manager</code>. This was especially important to prevent double-write issues, such as jobs which perform financial transactions.</li><li>At the time, <a href="https://github.com/kubernetes/kubernetes/pull/93370" target="_blank" rel="noopener noreferrer">CronJobControllerV2</a> did not yet exist, and several performance problems riddled the V1 controller. Because it did not use the informer pattern, Jobs were not scheduled timely and the controller could not scale to reconcile thousands of Jobs concurrently.</li></ol><div class="text--center"><img src="/assets/images/k8s-cronjob-adhoc-concurrency-policy-45b064381581af3b57adbd94d90ba13b.png"><p class="caption_y_hk">Similar feedback on limitations of the CronJob controller.<!-- --> <a href="https://github.com/kubernetes/kubernetes/issues/47538#issuecomment-549080643" target="_blank" rel="noopener noreferrer">GitHub</a></p></div><p>To add on, we were also looking to support features that were already existing in Rundeck in order to migrate our existing customers to the new platform based on Kubernetes. These features included but were not limited to:</p><ol><li>Specify job parameters, allowing us to use a single job as a template.</li><li>Schedule a job for later, rather than executing it immediately.</li><li>Enqueue a bunch of jobs to be run after the previous one finishes, such that they will not run concurrently.</li><li>Support complex job workflows.</li><li>Send notifications when a job starts, finishes, fails, etc.</li></ol><div class="text--center"><img src="/assets/images/rundeck-job-options-a2f10d60b538c4eda55d6813ca94e944.png"><p class="caption_y_hk">Example of parameterizing a job in Rundeck.</p></div><p>With all of the above in mind, we made a deliberate but painful choice to reinvent the wheel, because the existing controllers in core Kubernetes had no way to support some of these use cases without a complete redesign from scratch. üòì</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="designing-furiko">Designing Furiko<a class="hash-link" href="#designing-furiko" title="Direct link to heading">‚Äã</a></h2><p>Our initial design introduced the following concepts and ideas, which are roughly inspired from both Kubernetes and Rundeck.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="the-job-object">The Job object<a class="hash-link" href="#the-job-object" title="Direct link to heading">‚Äã</a></h3><p>A <a href="/docs/execution/job"><strong>Job</strong></a> is a single job execution, much like the K8s equivalent. If a JobConfig is scheduled to run every 3 hours, a new Job will be created every 3 hours.</p><p>The Job object should support features present in K8s, such as <a href="/docs/execution/job/parallelism">parallelism</a> and retry limits. In addition, we also implemented additional features, such as <a href="/docs/execution/job/timeout-retries#retries">retries using separate Pods</a>, <a href="/docs/execution/job/timeout-retries#task-level-timeouts">pending timeouts</a>, etc.</p><p>Users should not be interacting with the Job object directly most of the time, but instead interact directly with its parent, the JobConfig.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="the-jobconfig-object">The JobConfig object<a class="hash-link" href="#the-jobconfig-object" title="Direct link to heading">‚Äã</a></h3><p>A <a href="/docs/execution/jobconfig"><strong>JobConfig</strong></a> (roughly equivalent CronJob in K8s) is a single configuration (or template) for how jobs should be executed.</p><p>The JobConfig includes configuration such as <a href="/docs/execution/jobconfig/scheduling">automatic scheduling</a>, <a href="/docs/execution/jobconfig/concurrency">concurrency handling</a>, <a href="/docs/execution/jobconfig/job-options">job options</a>, and so on.</p><p>The difference from CronJob is that all Jobs <em>should</em> be created via its parent JobConfig. By having this assumption, we can track and observe the status of all Jobs for a single JobConfig. In addition, this also provides better user experience since we can now validate and add default parameters <a href="/docs/execution/job/adhoc-execution#optionvalues">when running a Job manually</a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="jobqueuecontroller">JobQueueController<a class="hash-link" href="#jobqueuecontroller" title="Direct link to heading">‚Äã</a></h3><p>The <a href="/docs/development/architecture/execution-controller#jobqueuecontroller"><strong>JobQueueController</strong></a> is responsible for <em>admitting</em> a Job to be started, based on some concurrency or scheduling constraints. It is responsible for the following:</p><ol><li>If the JobConfig is using the <a href="/docs/execution/jobconfig/concurrency#policy"><code>Forbid</code> concurrency policy</a>, it will not admit a Job when other Jobs are not yet finished.</li><li>If the Job is not due to be started (using <a href="/docs/execution/job/start-policy#startafter"><code>startAfter</code></a>), it will not yet be admitted.</li><li>Ensuring FIFO ordering of Jobs to be admitted based on their creation time (assuming no other constraints apply).</li></ol><p>This design allows us to move closer towards the user experience that our users enjoyed on Rundeck, while providing the reliability guarantees that allow our users to place trust in running millions of workloads a day in the company.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="sharing-furiko-with-the-world">Sharing Furiko with the world<a class="hash-link" href="#sharing-furiko-with-the-world" title="Direct link to heading">‚Äã</a></h2><p>Fast forward two years later, we were thrilled to have been receiving positive feedback for our internal Runonce platform. We were running millions of executions per day across multiple Kubernetes clusters, and &gt;99.999% on-time scheduling rate (i.e. almost no jobs were detected as overdue via monitoring).</p><p>At the same time, we found that there was no comprehensive, open-source, Kubernetes-native cron job platform available yet. As such, we decided to work on open-sourcing <a href="https://github.com/furiko-io/furiko" target="_blank" rel="noopener noreferrer">Furiko</a> with the rest of the community! ü•≥</p><p>Although core Kubernetes has made significant strides with regards to the CronJob controller recently (such as CronJobControllerV2 and timeZone support as of v1.24), we still found significant gaps that were not completely addressed. Additionally, we also know that existing tools such as <a href="https://argoproj.github.io/workflows" target="_blank" rel="noopener noreferrer">Argo Workflows</a> have similar functionality, but we believe that Furiko may be better positioned to focus on time-based scheduling of jobs on a massive scale.</p><p>Although initially developed as an internal platform inside of the company, <strong>Furiko is and will always be 100% open source</strong>. There are several features that are currently only available in our internal Runonce platform, but we remain hard at work to port over features or ideas from our internal version where appropriate. We also have started working on a community-maintained roadmap for Furiko, which can be found <a href="/docs/contributing/roadmap">here</a>.</p><p>We are still currently very early in our development of Furiko, and we welcome all contributions big or small. To find out more, check out our <a href="/docs/contributing/overview">Contribution Guide</a>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="try-it-out">Try it out<a class="hash-link" href="#try-it-out" title="Direct link to heading">‚Äã</a></h2><p>Check out Furiko on <a href="https://github.com/furiko-io/furiko" target="_blank" rel="noopener noreferrer">GitHub</a>, or the <a href="/docs/getting-started/install">installation guide</a> to get started on a Kubernetes cluster in less than a minute.</p><p>To view the full list of features of Furiko, check out the <a href="/docs/features">Features</a> page.</p><p>Let us know what you think! We are open to questions and feature requests over at our <a href="https://github.com/furiko-io/furiko/discussions" target="_blank" rel="noopener noreferrer">GitHub Discussions page</a>, or you can simply <a href="https://github.com/furiko-io/furiko/issues" target="_blank" rel="noopener noreferrer">open an issue</a> on our project on GitHub.</p>]]></content:encoded>
            <category>announcements</category>
            <category>furiko</category>
        </item>
        <item>
            <title><![CDATA[Refurbishing the Furiko Website]]></title>
            <link>https://furiko.io/blog/welcome</link>
            <guid>welcome</guid>
            <pubDate>Sat, 11 Jun 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[Welcome to the brand-new Furiko website! üéâ]]></description>
            <content:encoded><![CDATA[<p>Welcome to the brand-new Furiko website! üéâ</p><p>The new website is powered by <a href="https://docusaurus.io/" target="_blank" rel="noopener noreferrer">Docusaurus 2</a>, which is a modern static-site generator. The old documentation site was using <a href="https://www.mkdocs.org/" target="_blank" rel="noopener noreferrer">Mkdocs</a> which has definitely seen better days.</p><p>Many features such as versioning felt rather clunky to work around, and we needed additional blogging support as well. I decided to pull the trigger to migrate the old website to Docusaurus, which had been a breeze to do so. The old documentation site based on Mkdocs can be found here: <a href="https://github.com/furiko-io/docs" target="_blank" rel="noopener noreferrer">https://github.com/furiko-io/docs</a></p><p>Enjoy the new website! üòÅ</p>]]></content:encoded>
        </item>
    </channel>
</rss>